define(["exports","./GeometryOffsetAttribute-59cf1401","./Transforms-dccf26a2","./Matrix2-f0fc6cd3","./ComponentDatatype-5f63ec93","./when-229515d6","./RuntimeError-8f3d96ee","./GeometryAttribute-4ab4b9ae","./GeometryAttributes-b253752a","./IndexDatatype-c2b69fc2","./VertexFormat-af764a6f"],(function(t,e,a,n,i,r,o,m,s,u,c){"use strict";const l=new n.Cartesian3,f=new n.Cartesian3,d=new n.Cartesian3,C=new n.Cartesian3,p=new n.Cartesian3,y=new n.Cartesian3(1,1,1),_=Math.cos,A=Math.sin;function h(t){t=r.defaultValue(t,r.defaultValue.EMPTY_OBJECT);const e=r.defaultValue(t.radii,y),a=r.defaultValue(t.innerRadii,e),o=r.defaultValue(t.minimumClock,0),m=r.defaultValue(t.maximumClock,i.CesiumMath.TWO_PI),s=r.defaultValue(t.minimumCone,0),u=r.defaultValue(t.maximumCone,i.CesiumMath.PI),l=Math.round(r.defaultValue(t.stackPartitions,64)),f=Math.round(r.defaultValue(t.slicePartitions,64)),d=r.defaultValue(t.vertexFormat,c.VertexFormat.DEFAULT);this._radii=n.Cartesian3.clone(e),this._innerRadii=n.Cartesian3.clone(a),this._minimumClock=o,this._maximumClock=m,this._minimumCone=s,this._maximumCone=u,this._stackPartitions=l,this._slicePartitions=f,this._vertexFormat=c.VertexFormat.clone(d),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}h.packedLength=2*n.Cartesian3.packedLength+c.VertexFormat.packedLength+7,h.pack=function(t,e,a){return a=r.defaultValue(a,0),n.Cartesian3.pack(t._radii,e,a),a+=n.Cartesian3.packedLength,n.Cartesian3.pack(t._innerRadii,e,a),a+=n.Cartesian3.packedLength,c.VertexFormat.pack(t._vertexFormat,e,a),a+=c.VertexFormat.packedLength,e[a++]=t._minimumClock,e[a++]=t._maximumClock,e[a++]=t._minimumCone,e[a++]=t._maximumCone,e[a++]=t._stackPartitions,e[a++]=t._slicePartitions,e[a]=r.defaultValue(t._offsetAttribute,-1),e};const x=new n.Cartesian3,b=new n.Cartesian3,k=new c.VertexFormat,w={radii:x,innerRadii:b,vertexFormat:k,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};let P;h.unpack=function(t,e,a){e=r.defaultValue(e,0);const i=n.Cartesian3.unpack(t,e,x);e+=n.Cartesian3.packedLength;const o=n.Cartesian3.unpack(t,e,b);e+=n.Cartesian3.packedLength;const m=c.VertexFormat.unpack(t,e,k);e+=c.VertexFormat.packedLength;const s=t[e++],u=t[e++],l=t[e++],f=t[e++],d=t[e++],C=t[e++],p=t[e];return r.defined(a)?(a._radii=n.Cartesian3.clone(i,a._radii),a._innerRadii=n.Cartesian3.clone(o,a._innerRadii),a._vertexFormat=c.VertexFormat.clone(m,a._vertexFormat),a._minimumClock=s,a._maximumClock=u,a._minimumCone=l,a._maximumCone=f,a._stackPartitions=d,a._slicePartitions=C,a._offsetAttribute=-1===p?void 0:p,a):(w.minimumClock=s,w.maximumClock=u,w.minimumCone=l,w.maximumCone=f,w.stackPartitions=d,w.slicePartitions=C,w.offsetAttribute=-1===p?void 0:p,new h(w))},h.createGeometry=function(t){const o=t._radii;if(o.x<=0||o.y<=0||o.z<=0)return;const c=t._innerRadii;if(c.x<=0||c.y<=0||c.z<=0)return;const y=t._minimumClock,h=t._maximumClock,x=t._minimumCone,b=t._maximumCone,k=t._vertexFormat;let w,P,g=t._slicePartitions+1,v=t._stackPartitions+1;g=Math.round(g*Math.abs(h-y)/i.CesiumMath.TWO_PI),v=Math.round(v*Math.abs(b-x)/i.CesiumMath.PI),g<2&&(g=2),v<2&&(v=2);let F=0;const V=[x],M=[y];for(w=0;w<v;w++)V.push(x+w*(b-x)/(v-1));for(V.push(b),P=0;P<g;P++)M.push(y+P*(h-y)/(g-1));M.push(h);const T=V.length,D=M.length;let G=0,L=1;const O=c.x!==o.x||c.y!==o.y||c.z!==o.z;let I=!1,E=!1,z=!1;O&&(L=2,x>0&&(I=!0,G+=g-1),b<Math.PI&&(E=!0,G+=g-1),(h-y)%i.CesiumMath.TWO_PI?(z=!0,G+=2*(v-1)+1):G+=1);const N=D*T*L,R=new Float64Array(3*N),U=e.ArrayCommon.fill(new Array(N),!1),S=e.ArrayCommon.fill(new Array(N),!1),B=g*v*L,W=6*(B+G+1-(g+v)*L),Y=u.IndexDatatype.createTypedArray(B,W),J=k.normal?new Float32Array(3*N):void 0,X=k.tangent?new Float32Array(3*N):void 0,Z=k.bitangent?new Float32Array(3*N):void 0,j=k.st?new Float32Array(2*N):void 0,q=new Array(T),H=new Array(T);for(w=0;w<T;w++)q[w]=A(V[w]),H[w]=_(V[w]);const K=new Array(D),Q=new Array(D);for(P=0;P<D;P++)Q[P]=_(M[P]),K[P]=A(M[P]);for(w=0;w<T;w++)for(P=0;P<D;P++)R[F++]=o.x*q[w]*Q[P],R[F++]=o.y*q[w]*K[P],R[F++]=o.z*H[w];let $,tt,et,at,nt=N/2;if(O)for(w=0;w<T;w++)for(P=0;P<D;P++)R[F++]=c.x*q[w]*Q[P],R[F++]=c.y*q[w]*K[P],R[F++]=c.z*H[w],U[nt]=!0,w>0&&w!==T-1&&0!==P&&P!==D-1&&(S[nt]=!0),nt++;for(F=0,w=1;w<T-2;w++)for($=w*D,tt=(w+1)*D,P=1;P<D-2;P++)Y[F++]=tt+P,Y[F++]=tt+P+1,Y[F++]=$+P+1,Y[F++]=tt+P,Y[F++]=$+P+1,Y[F++]=$+P;if(O){const t=T*D;for(w=1;w<T-2;w++)for($=t+w*D,tt=t+(w+1)*D,P=1;P<D-2;P++)Y[F++]=tt+P,Y[F++]=$+P,Y[F++]=$+P+1,Y[F++]=tt+P,Y[F++]=$+P+1,Y[F++]=tt+P+1}if(O){if(I)for(at=T*D,w=1;w<D-2;w++)Y[F++]=w,Y[F++]=w+1,Y[F++]=at+w+1,Y[F++]=w,Y[F++]=at+w+1,Y[F++]=at+w;if(E)for(et=T*D-D,at=T*D*L-D,w=1;w<D-2;w++)Y[F++]=et+w+1,Y[F++]=et+w,Y[F++]=at+w,Y[F++]=et+w+1,Y[F++]=at+w,Y[F++]=at+w+1}if(z){for(w=1;w<T-2;w++)at=D*T+D*w,et=D*w,Y[F++]=at,Y[F++]=et+D,Y[F++]=et,Y[F++]=at,Y[F++]=at+D,Y[F++]=et+D;for(w=1;w<T-2;w++)at=D*T+D*(w+1)-1,et=D*(w+1)-1,Y[F++]=et+D,Y[F++]=at,Y[F++]=et,Y[F++]=et+D,Y[F++]=at+D,Y[F++]=at}const it=new s.GeometryAttributes;k.position&&(it.position=new m.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:R}));let rt=0,ot=0,mt=0,st=0;const ut=N/2;let ct;const lt=n.Ellipsoid.fromCartesian3(o),ft=n.Ellipsoid.fromCartesian3(c);if(k.st||k.normal||k.tangent||k.bitangent){for(w=0;w<N;w++){ct=U[w]?ft:lt;const t=n.Cartesian3.fromArray(R,3*w,l),e=ct.geodeticSurfaceNormal(t,f);if(S[w]&&n.Cartesian3.negate(e,e),k.st){const t=n.Cartesian2.negate(e,p);j[rt++]=Math.atan2(t.y,t.x)/i.CesiumMath.TWO_PI+.5,j[rt++]=Math.asin(e.z)/Math.PI+.5}if(k.normal&&(J[ot++]=e.x,J[ot++]=e.y,J[ot++]=e.z),k.tangent||k.bitangent){const t=d;let a,i=0;if(U[w]&&(i=ut),a=!I&&w>=i&&w<i+2*D?n.Cartesian3.UNIT_X:n.Cartesian3.UNIT_Z,n.Cartesian3.cross(a,e,t),n.Cartesian3.normalize(t,t),k.tangent&&(X[mt++]=t.x,X[mt++]=t.y,X[mt++]=t.z),k.bitangent){const a=n.Cartesian3.cross(e,t,C);n.Cartesian3.normalize(a,a),Z[st++]=a.x,Z[st++]=a.y,Z[st++]=a.z}}}k.st&&(it.st=new m.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:j})),k.normal&&(it.normal=new m.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:J})),k.tangent&&(it.tangent=new m.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:X})),k.bitangent&&(it.bitangent=new m.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:Z}))}if(r.defined(t._offsetAttribute)){const a=R.length,n=new Uint8Array(a/3),r=t._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.ArrayCommon.fill(n,r),it.applyOffset=new m.GeometryAttribute({componentDatatype:i.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:n})}return new m.Geometry({attributes:it,indices:Y,primitiveType:m.PrimitiveType.TRIANGLES,boundingSphere:a.BoundingSphere.fromEllipsoid(lt),offsetAttribute:t._offsetAttribute})},h.getUnitEllipsoid=function(){return r.defined(P)||(P=h.createGeometry(new h({radii:new n.Cartesian3(1,1,1),vertexFormat:c.VertexFormat.POSITION_ONLY}))),P},t.EllipsoidGeometry=h}));
